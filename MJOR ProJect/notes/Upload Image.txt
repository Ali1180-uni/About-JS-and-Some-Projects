-> Ok there are two conflicts to Upload image
1. Create Frontend to upload image
2. Backend to Accept image

-> BSON format have limits to save the Data
-> Now MongoDB never Accepts the Image Directly so What we do, We Setup a Cloud system like(AWS) to upload the images or Files then we 
-> Take the links of these files and save them in MongoDB to use it

-> Now one more issue that the Current Middleware is just for URL --> app.use(Express.urlencoded({ extended: true }));
// Thats why we Got empty string if we upload the image bcz  it never reads the data we post


-> So for this issue we use another item in the form which data we want to post in Specific Formats like images
-> enctype = "multipart/form-data" -> The form having this type will able to post the files 

<form action="/profile" method="post" enctype="multipart/form-data">
  <input type="file" name="avatar" />
</form>

-> Now parse this data for backend so we must install a package
-> npm i multer
-> it is used to parse the specific image into the specific format accessable to use in backend

NOTE: Multer will not process any form which is not multipart (multipart/form-data).

const express = require('express')
const multer  = require('multer')
const upload = multer({ dest: 'uploads/' }) // For Image Uploading temporarily in futuire we will use cloudinary or some other service

// This line represent the destination of the image
->  According to this line File is saved in ulpoads folder in specific format which is automatically created by multer

app.post('/profile', upload.single('avatar'), function (req, res, next) {  --> passing Middleware

  // req.file is the `avatar` file --> in our case we upload image instead of avatar
  // req.body will hold the text fields, if there were any

})

--> Using request.file bcz it stores all the data about file

.post( upload.single('listing[image]'), (req,res)=>{  --> Using listing[image]
        res.send(req.file);
});

we Got this type of response after it ->

{
  "fieldname": "listing[image]",
  "originalname": "Aggrigate Func() DB.png",
  "encoding": "7bit",
  "mimetype": "image/png",
  "destination": "uploads/",
  "filename": "1ad39d305616a7991fe3adc096ddea36",
  "path": "uploads\\1ad39d305616a7991fe3adc096ddea36",
  "size": 259399
}

-> Ok here we are using the Cloudinary (loggedin by github)
for the Cloud data save and i got my API_KEYS & CLOUD_API_SECRET form there now for its use we must use 2 new packages which helps us a lot

-> npm i cloudinary
-> npm i multer-storage-cloudinary

// Ok cloudinary ka version 1 install hoa hn ku ke version 2 sahi nai tha 
// ok first create a file named CloudConfig.js

-> Code

const cloudinary = require('cloudinary').v2;   // V2 required
const { CloudinaryStorage } = require('multer-storage-cloudinary'); // Multer storage required

if (!process.env.CLOUD_NAME || !process.env.CLOUD_API_KEY || !process.env.CLOUD_API_SECRET) {  // For Error Tracking
    console.error('Missing required Cloudinary environment variables');
    process.exit(1);
}

// configure cloudinary v2
cloudinary.config({ 
    cloud_name: process.env.CLOUD_NAME,  // initializing Data
    api_key: process.env.CLOUD_API_KEY, 
    api_secret: process.env.CLOUD_API_SECRET 
});

const storage = new CloudinaryStorage({
    cloudinary: cloudinary,
    params: {
        folder: 'Hi_Tour', // The name of the folder in cloudinary
        allowedFormats: ['png', 'jpg', 'jpeg'], // restricted to common image formats
        format: 'jpg' // optional: convert all images to jpg format
    },
});

module.exports = { storage, cloudinary };

Now We can use it in our listingCRUD --->

const { storage } = require('../CloudConfig.js');
const upload = multer({ storage }); // For Image Uploading Using Cloudinary ab is se Cludinary me jayega
// const upload = multer({ dest: 'uploads/' }); // ye save krwata tha local

-> Now we got this data if we upload on Cloudinary

{
  "fieldname": "listing[image]",
  "originalname": "Aggrigate Func() DB.png",
  "encoding": "7bit",
  "mimetype": "image/png",
  "path": "https://res.cloudinary.com/dvxvnu3pk/image/upload/v1756116802/Hi_Tour/hdtwyyjvifpyxvvmplmn.jpg", // At this link we find our pic
  "size": 34802,
  "filename": "Hi_Tour/hdtwyyjvifpyxvvmplmn"
}

-> Now we just pass multer Middleware in post  ->  upload.single('listing[image]')

-->  .post(isLoggedIn, validateListing, upload.single('listing[image]'), wrapAsync(add));

Now i setup my Listing Model image part according to it -->

module.exports.add = async (req, res, next) => { // Post request
    let url = req.file.path;  // path from cloudinary saved in req.file
    let filename = req.file.filename; // filename from cloudinary saved in req.file
    let result = listingSchema.validate(req.body); // Validate the incoming data against the Joi schema
    if (result.error) {
        throw new CusErrHandle(400,result.error);
    }
    let newList = new list(req.body.listing); //  Affective way to Avoid The Bulky Code
    newList.owner = req.user._id; // Assign the owner of the listing to the currently logged-in user
    newList.image = {url, filename}; // --------------------> Here i setup the both of them as image properties
    // The req.user._id is the ID of the user who is currently logged in,
    await newList.save();
    req.flash("Success","New Location Added");
    res.redirect("/listing");
}

// I also modify my Model of listing

        image: {
            url: String,
            filename: String,

            // type: String,
            // default: "https://unsplash.com/photos/red-canoes-are-stacked-near-a-mountain-lake-yHc2gPFqJek",
            // set: (v) => v === ""
            // ? "https://unsplash.com/photos/red-canoes-are-stacked-near-a-mountain-lake-yHc2gPFqJek"
            // : v,
            // required: true
        },

// Also in EJS pages i wrote (Lists.image.url) instead of (Lists.image)
